<!DOCTYPE html>
<html>
<head>
    <title>Accessible App</title>
    <!--  (c) 2013 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Sun Aug 04 2013 11:25:54 GMT-0700 (PDT) -->
    <script type="text/javascript" src="/apps/2.0rc1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    
    projectSelector: null,
    projectStore: null,
    grids: {},

    table_size: 10,
    defaults: { padding: 10 },
    items: [ 
        {xtype:'container', items: [ 
            {xtype: 'container', html: '<h1>Top of the App</h1> ' +
                    '<p>This app allows a user to select a project and find stories within that project. ' +
                    'Below this paragraph, there is a combobox listing projects and a button that starts the query. ' +
                    'The app will generate two tables, each containing the first ten items owned by the current ' +
                    'user for the selected project; one table for user stories and one for defects.</p>' }
        ]},
        {xtype:'container',items: [
            {xtype:'container',html:'<h2>Query Options</h2>'},
            {xtype:'container',itemId:'selector_box', defaults: { padding: 5, margin: 5 }, layout: { type: 'hbox' } }
        ]},
        {xtype:'container',itemId:'grid_box', items: [
            {xtype:'container',html:'<h2>Resulting User Story Grid Area</h2>'},
            {xtype:'container',itemId:'hierarchicalrequirement_grid_box'},
            {xtype:'container',html:'<h2>Resulting Defect Grid Area</h2>'},
            {xtype:'container',itemId:'defect_grid_box'}
        ]},
        {xtype:'container',itemId:'editor_box', items: [{xtype:'container',html:'<h2>Edit Area</h2>'}] },
        {xtype:'container', items: [
            {xtype:'container',html:'<h2>Alerts</h2>'},
            {xtype:'container',itemId:'alert_area',id:'alert_area'}
        ]}
    ],
    launch: function() {       
        //Ext.getBody().set({ role: 'application' });
        this._alert("The application is loading.");
        this._prepareBuffer();
        this.projectStore = Ext.create('Rally.data.WsapiDataStore', {
            model: 'Project',
            autoLoad: true,
            limit: 400,
            fetch: ['ObjectID', 'Name'],
            listeners: {
                load: this._onProjectStoreLoaded,
                scope: this
            },
            filters: [
                {
                    property: 'State',
                    value: 'Open'
                }
            ],
            sorters: [
                {
                    property: 'Name',
                    direction: 'ASC'
                }
            ]
        });
    },
    
    _onProjectStoreLoaded: function(store, data) {
        this.projectSelector = Ext.create('Rally.technicalservices.accessible.Combobox', {
            store: store,
            componentId: 'projectSelector',
            fieldLabel: 'Project'
        });
        
        this.down('#selector_box').add(this.projectSelector);
        
        this.down('#selector_box').add({
            xtype: 'button',
            text: 'Get Stories and Defects',
            itemId: 'run_query_button',
            buttonLabel : 'Get Stories and Defects',
            handler: this._getItems,
            scope: this
        });   

        Ext.get('alert_area').set({role:'alert'});
        
        this.down('#run_query_button').focus();
        this._alert("The application is loaded and available in an iFrame on the page. " +
                "Focus should be on the Get Stories button, which is after the project selector combo box.");
    },
    _getItems: function() {
        this.return_message_array = []; // fill with message from each of the queries
        // Get the ref of the selected project
        var selected_project_ref = projectSelector.value;
        var selected_project_name = projectSelector.options[projectSelector.selectedIndex].text;
        this._alert("Fetching Stories and Defects for " + selected_project_name + " project." );
        this._getItemsByType("hierarchicalrequirement",selected_project_ref);
        this._getItemsByType("defect",selected_project_ref);
    },
    // Loads/refreshes grid with subset of Stories from selected project
    _getItemsByType: function(type,project_ref) {
        this._log(['_getItems',type]);
        var me = this;


        // Clear out existing grid if present
        if (this.grids[type]) { this.grids[type].destroy(); }
           
        
        var store = Ext.create('Rally.data.WsapiDataStore',{
            model: type,
            limit: me.table_size,
            pageSize: me.table_size,
            context: {
                project: project_ref,
                projectScopeUp: false,
                projectScopeDown: false
            },
            filters: [ { property: 'Owner', value: 'currentuser' }],
            autoLoad:true,
            listeners: {
                scope: this,
                load: function(store,data,success){
                    this._makeGrid(store,type);
                }
            }
        });
        
    },
    edit_fields: {
        hierarchicalrequirement:  [
            {text:'Formatted ID',dataIndex:'FormattedID'},
            {text:'Name', dataIndex:'Name'},
            {text:'Schedule State', dataIndex:'ScheduleState' },
            {text:'Size', dataIndex:'PlanEstimate' },
            {text:'Description', dataIndex:'Description'}
        ],
        defect:  [
            {text:'Formatted ID',dataIndex:'FormattedID'},
            {text:'Name', dataIndex:'Name'},
            {text:'Schedule State', dataIndex:'ScheduleState' },
            {text:'State', dataIndex:'State'},
            {text:'Size', dataIndex:'PlanEstimate' }
        ]
    },
    table_columns: {
        hierarchicalrequirement: [
                {text:'ID', dataIndex:'FormattedID'},
                {text:'Name', dataIndex:'Name'},
                {text:'Schedule State', dataIndex:'ScheduleState'},
                {text:'Size', dataIndex:'PlanEstimate' }
            ],
            defect: [
                {text:'ID', dataIndex:'FormattedID'},
                {text:'Name', dataIndex:'Name'},
                {text:'Schedule State', dataIndex:'ScheduleState'},
                {text:'Defect State',dataIndex:'State'},
                {text:'Size', dataIndex:'PlanEstimate' }
            ]
    },
    friendly_names: {
        "Defect": "Defect",
        "defect": "Defect",
        "userstory": "User Story",
        "hierarchicalrequirement":"User Story"
    },
    /*
     * make a grid, given a store and the global grid we're talking about
     * (for story or defect grid)
     */
    _makeGrid: function(store, type) {
        this._log(["_makeGrid",type]);
        var me = this;
        if (this.grids[type]) { this.grids[type].destroy(); }
        
        this.grids[type] = Ext.create('Rally.technicalservices.accessible.grid',{
            store: store,
            title: me.friendly_names[type] || type,
            caption: 'Table of ' + me.friendly_names[type] + "s",
            columns: me.table_columns[type],
            editFieldName: 'Name',
            listeners: {
                scope: this,
                afterrender: function() {
                    me.return_message_array.push("Loaded " + me.grids[type].getCount() + " " + me.friendly_names[type] + "s into a table.");
                    if ( me.return_message_array.length == 2 ) {
                        me._alert(me.return_message_array.join(', '));
                    }
                },
                recordeditclick: function(g, recordToEdit) {
                    this._log(recordToEdit);
                    this._makeEditor(recordToEdit);
                }
            }
        });
        
        this.down('#' + type + '_grid_box').add(this.grids[type]);
    },
    /*
     * expecting record, [ {text:'field name',dataIndex:'fieldname'} ]
     */
    _makeEditorFieldDefsAndEditor: function(record) {
        var me = this;
        me._log("Field Editor Defs");
        var new_field_array = [];
        var type = record.get('_type');
        var field_array = this.edit_fields[type];
        
        Rally.data.ModelFactory.getModel({
            type: type,
            success: function(model) {
                Ext.Array.each(field_array, function(field) {
                    model.getField(field.dataIndex).getAllowedValueStore().load({
                        callback: function(records, operation, success) {
                            var allowed_values = [];
                            Ext.Array.each(records, function(allowedValue) {
                                allowed_values.push(allowedValue.get('StringValue'));
                            });
                            me._log(field.dataIndex + " ... " + allowed_values.join(','));
                            var new_field_def = field;
                            field.editor = { xtype:'rallytextfield' };
                            if ( allowed_values.length > 0 ) {
                                field.editor = {
                                    xtype: 'tsaccessiblefieldcombobox',
                                    model: type,
                                    field: field.dataIndex,
                                    fieldLabel: field.text,
                                    componentId: 'comboBox-' + field.dataIndex
                                }
                            } else {
                                var rally_type = model.getField(field.dataIndex).attributeDefinition.AttributeType;
                                if (rally_type === "TEXT"){
                                    field.editor = {
                                        field: field.dataIndex,
                                        fieldLabel: field.text,
                                        xtype: 'tsaccessiblehtmleditor',
                                        enableFormat: false,
                                        enableFontSize: false,
                                        enableColors: false,
                                        enableAlignments: false,
                                        enableFont: false,
                                        createLinkText: false,
                                        enableLists: false,
                                        enableLinks: false,
                                        enableSourceEdit: false,
                                        listeners: {
                                            tab: function(ed,shift_key_pressed) {
                                                me._moveToNextItem(ed,shift_key_pressed);
                                            }
                                        }
                                    }
                                }
                            }
                            me._log(["field",model.getField(field.dataIndex)]);
                            if ( model.getField(field.dataIndex).readOnly ) {
                                field.editor.readOnly = true;
                            }
                            new_field_array.push(field);
                            
                            if (field_array.length == new_field_array.length ) {
                                me.recordEditor = Ext.create('Rally.technicalservices.accessible.editor',{
                                    fields: field_array,
                                    record: record,
                                    buttons: [
                                        { text: 'Save' },
                                        { text: 'Cancel' }
                                    ],
                                    listeners: {
                                        buttonclick: function(editor,record,button) {
                                            if ( button.text == "Save" ) {
                                                me._saveRecord(record);
                                            } else {
                                                me._alert('Cancel pressed. Editor cleared.');
                                                me.recordEditor.destroy();
                                            }
                                        }
                                    }
                                });
                             
                                me.down('#editor_box').add(me.recordEditor);
                                
                                me._alert("Record " + record.get('FormattedID') + " available for editing in the edit area");
                                me.recordEditor.setFocusToItemNumber(0,true);
                            }
                        }
                    });
                });
            }
        });
    },
    // hack because the html editor steals focus and won't give it back from tabbing
    _moveToNextItem: function(component,shift_key_pressed) {
        var me = this;
        var direction = 1;
        if ( shift_key_pressed ) { direction = -1; }
        if (me.recordEditor) {
            if ( me.recordEditor.items ) {
                var next_idx = Ext.Array.indexOf(me.recordEditor.items,component) + direction;
                me.recordEditor.setFocusToItemNumber(next_idx,false);
            }
        }
    },
    _makeEditor: function(record) {
        this._log(["_makeEditor",record]);
        var me = this;
        if (this.recordEditor) {
            this.recordEditor.destroy();
        }
        
        this._makeEditorFieldDefsAndEditor(record);
    },
    
    _saveRecord: function(record) {
        this._log('_saveRecord');
        var me = this;
        me._alert("Saving Record.");
        var type = record.get('_type');
        
        // TODO: have the editor return the new values
        var items = this.recordEditor.items;
        items.each( function(item) {
            if (item.value && item.itemId ) {
                var index = parseInt( item.itemId.replace(/^\D+/g, ''), 10 );
                var field_name = me.edit_fields[type][index].dataIndex;
                record.set(field_name, item.getValue());
                me._log(["Setting field/value",field_name, item.getValue()]);
            }
        });
        
        record.save({
            callback: function(result, operation) {
                if(operation.wasSuccessful()) {
                    me._alert("Record saved, editor cleared");
                    // remove the editor
                    me.recordEditor.destroy();
                    // refresh the grid
                    me._getItems();
                } else {
                    me._log(operation);
                    alert("Could not save the record. The message from the server is: " +
                        operation.error.errors[0] );
                }
            }
        });
        

    },

    _log: function(msg) {
        window.console && console.log( msg );  
    },
    
    _alert: function(message) {
        this.down('#alert_area').removeAll();
        this.down('#alert_area').add({ xtype:'container',html:'<span role="alert">' + message + "</span>"});

        var objHidden = document.getElementById('virtualbufferupdate');
    
        if (objHidden)
        {
            if (objHidden.getAttribute('value') == '1') {
                objHidden.setAttribute('value', '0');
            } else {
                objHidden.setAttribute('value', '1');
            }
        } else {
            this._prepareBuffer();
        }
    },
    _prepareBuffer: function(){
        var objNew = document.createElement('p');
        var objHidden = document.createElement('input');
    
        objHidden.setAttribute('type', 'hidden');
        objHidden.setAttribute('value', '1');
        objHidden.setAttribute('id', 'virtualbufferupdate');
        objHidden.setAttribute('name', 'virtualbufferupdate');
    
        objNew.appendChild(objHidden);
        Ext.getBody().appendChild(objNew);
    }
    
    
});
/*
 * Straight override of parts of Ext components so we don't have to subclass them
 */

/**
 * A combobox that takes a store and displays a dropdown that doesn't have
 * all the cruft that interferes with a Jaws reader.
 * 
 * The drop-down options display name and provide the Rally ref.
 * 
 */
 Ext.define('Rally.technicalservices.accessible.Combobox', {
    extend: 'Ext.Component',
    alias: 'widget.tsaccessiblecombobox',
    
    // Default configuration parameters
    config: {
        store: null,        
        componentId : null,
        /**
         * @cfg {String}
         * The underlying data field name to bind to this ComboBox.
         * 
         * Defaults to 'Name'
         */
        displayField: 'Name',
        /**
         * @cfg {String} label
         * String to display to the left of the combobox
         */
        label: null,
        valueField: '_ref',
         /**
         * @cfg {Object} value
         * A value to initialize this field with.
         */
        value: null
    },
        
    // Constructor
    initComponent: function(){
        this.callParent();
        if ( this.componentId === null ) {
            this.componentId = "comboBox-" + this.valueField;
        }
    },

    renderTpl: [
        '<tpl if="label">',
        '<label for={componentId}>{label}:</label>',
        '</tpl>',
        '<select id={componentId}>',
        '<tpl for="items">',
            '<option value="{valueField}">{displayField}</option>',
        '</tpl>',
        '</select>'
    ],
    
    getTemplateArgs: function() {
        var me = this;
        var data = [];
        if ( me.store !== null ) {
            var records = this.store.getRecords();
            Ext.Array.each(records, function(record){
                data.push({
                    valueField: record.get(me.valueField),
                    displayField: record.get(me.displayField)
                });
            });
        }
        return {
            componentId: this.componentId,
            items: data,
            label: this.fieldLabel
        }
    },

    beforeRender: function() {
        var me = this;
        me.callParent();
        Ext.applyIf(me.renderData, me.getTemplateArgs());
    },
    
    getValue: function() {
        var my_html = this.getEl().dom;
        var selector = Ext.dom.Query.selectNode('select',my_html);
        var options = Ext.dom.Query.select('option',selector);
        var index = selector.selectedIndex || 0;
        return options[index].value;
    }
});

Ext.define('Rally.technicalservices.accessible.editor',{
    extend: 'Ext.container.Container',
    alias: 'widget.tsaccessibleeditor',
    config: {
         /**
         * @cfg {Ext.data.Model} record
         * The Rally record to edit
         */
        record: null,
        /**
         * @cfg {Array} fields
         * A field configuration definition.  Each item in the array:
         * @cfg {String} Name
         * @cfg {String} dataIndex
         * 
         * for example, 
         * fields: [ { Name: 'Item Name', dataIndex: 'Name' } ]
         */
        fields: [],
        /**
         * @cfg {Object/Object[]} buttons
         * Convenience config used for adding buttons docked to the bottom of the panel. 
         *
         *     buttons: [
         *       { text: 'Button 1' }
         *     ]
         *     
         * Clicking a button fires the buttonclick event
         */
        buttons: []
    },
    initComponent: function() {
        this.callParent();
        this.addEvents(
            /**
             * @event buttonclick
             * Fires when one of the buttons is clicked
             * @param {Rally.technicalservices.accessible.editor} this
             * @param {Ext.data.Model} Rally record 
             * @param {Ext.button} The button that was clicked
             */
            'buttonclick'
        );
    },
    renderTpl: "",
    getTemplateArgs: function() {
        if ( this.fields.length == 0 ) {
            this.renderTpl = "No fields supplied";
        }
        
        if ( this.record == null ) {
            this.renderTpl = "No record supplied";
        }
        return {
            fields: this.fields
        }
    },
    beforeRender: function() {
        var me = this;
        me.callParent();
        
        Ext.applyIf(me.renderData, me.getTemplateArgs());
    },
    getFieldObjects: function() {
        var me = this;
        var items = [];
        var value = "";

        for (var i=0; i<me.fields.length; i++) {
            if ( me.record ) {
                value = me.record.get(me.fields[i].dataIndex)
            }
            console.log("value",value);
            
            var xtype = 'rallytextfield';
            if ( me.fields[i].editor && typeof(me.fields[i].editor) == "string") {
                xtype = me.fields[i].editor;
            }
            var thisItem = {
                xtype: xtype,
                fieldLabel: me.fields[i].text,
                value: value,
                itemId: "field_" + i
            };
            if ( me.fields[i].editor && typeof(me.fields[i].editor != "string") ) {
                Ext.merge(thisItem,me.fields[i].editor);
            }
            items.push(thisItem);
        }
        return items;
    },
    initItems : function() {
        var me = this,
            items = me.items;

        var field_objects = me.getFieldObjects();
        if ( field_objects.length > 0 && me.record) {
            if ( items ) {
                items = Ext.Array.merge( field_objects, items );
            } else {
                items = field_objects;
            }
            
            Ext.Array.each(me.buttons, function(button){
                var basic_definition = {
                    xtype: 'button',
                    text: 'No Label Supplied',
                    handler: function() { me.fireEvent('buttonclick', me, me.record, this); },
                    scope: this
                };
                
                items.push(Ext.merge(basic_definition,button));
            });
            
        }
        /**
         * The MixedCollection containing all the child items of this container.
         * @property items
         * @type Ext.util.AbstractMixedCollection
         */
        me.items = new Ext.util.AbstractMixedCollection(false, me.getComponentId);

        if (items) {
            if (!Ext.isArray(items)) {
                items = [items];
            }

            me.add(items);
        }
    },
    setFocusToItemNumber: function(next_idx,select_text){
        var me = this;
        if ( next_idx > -1 && next_idx < me.items.length ) {
            me.items.getAt(next_idx).focus(select_text);
        }
    }
});
/**
 * A combobox that takes a field & model type and displays a dropdown that doesn't have
 * all the cruft that interferes with a Jaws reader.
 * 
 */
 Ext.define('Rally.technicalservices.accessible.combobox.FieldValueCombobox', {
    extend: 'Rally.technicalservices.accessible.Combobox',
    alias: 'widget.tsaccessiblefieldcombobox',
    
    // Default configuration parameters
    config: {
        /**
         * @cfg {String} fieldLabel
         * The fieldname from the model where allowed values can be set
         * 
         * Defaults to 'ScheduleState'
         */
        field: 'ScheduleState',
        /**
         * @cfg {String} model
         * The name of the model that has the assigned field
         * 
         * Defaults to 'UserStory'
         */
        model: 'UserStory',
        valueField: 'StringValue',
        displayField: 'StringValue'
    },
    
    constructor: function(config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },
    initComponent: function(){
        var autoLoad, storeListeners;
        this.addEvents(
            /**
             * @event
             * Fires when the combobox's store has been loaded
             * @param {Rally.technicalservices.accessible.combobox.FieldValueCombobox} this
             */
            'load'
        );
        this.callParent();
        
        this.store = Ext.create('Ext.data.Store', {
            fields: [this.valueField, this.displayField],
            data: []
        });
        
        this.store.on('load',this._onStoreLoad, this);
        
        this.on('afterrender', this._onAfterRender, this);

        if (Ext.isString(this.model)) {
            this._fetchModel();
        } else {
            if (Ext.isString(this.field)) {
                this.field = this.model.getField(this.field);
            }
            this._populateStore();
        }
    },

    _fetchModel: function() {
        Rally.data.ModelFactory.getModel({
            context: this.context,
            type: this.model,
            success: this._onModelRetrieved,
            scope: this
        });
    },
    
    _onStoreLoad: function(store) {
        var me = this;
        me.tpl = me.renderTpl;
        this.update(me.getTemplateArgs());
        if (this.value) {
            this.setValue(this.value);
        }
        this.fireEvent('load', this);
    },

    _onModelRetrieved: function(model) {
        this.model = model;
        this.field = this.model.getField(this.field);
        this._populateStore();
    },

    _populateStore: function() {
        this.field.getAllowedValueStore().load({
            callback: function(records, operation, success) {
                var store = this.store;
                if (!store) {
                    return;
                }
                var noEntryValues = [],
                    labelValues = _.map(
                        _.filter(records, this._hasStringValue),
                        this._convertAllowedValueToLabelValuePair,
                        this
                    );

                if (this.field.required === false) {
                    var name = "-- No Entry --",
                        value = "";
                    if (this.field.attributeDefinition.AttributeType.toLowerCase() === 'rating') {
                        name = "None";
                        value = "None";
                    }
                    noEntryValues.push(this._convertToLabelValuePair(name, value));
                }
                store.loadRawData(noEntryValues.concat(labelValues));
            },
            scope: this
        });
    },
    
    _onAfterRender: function() {
        this._afterRender = true;
        if(this._storeLoaded) {
            this.fireEvent('ready', this);
        }
    },
        
    getTemplateArgs: function() {
        var me = this;
        var data = [];
        if ( me.store !== null ) {
            me.store.each(function(record){
                data.push({
                    valueField: record.get(me.valueField),
                    displayField: record.get(me.displayField)
                });
            });
        }
        return {
            componentId: this.componentId,
            items: data,
            label: this.fieldLabel
        }
    },
    
    setValue: function( new_value ) {
        var my_html = this.getEl().dom;
        var selector = Ext.dom.Query.selectNode('select',my_html);
        var options = Ext.dom.Query.select('option',selector);
        
        Ext.Array.each(options, function(option,idx){
            if (option.value == new_value) {
                selector.selectedIndex = idx;
            }
        });
    }

});

/*
 * accessible html editor, extended to capture tab key and pass focus, and also
 * to clean some of the text that won't save
 */
Ext.define('Rally.technicalservices.accessible.htmleditor',{
    extend: 'Ext.form.field.HtmlEditor',
    alias: 'widget.tsaccessiblehtmleditor',
    initComponent: function() {
        this.callParent();
        this.addEvents(
        /**
             * @event tab
             * Fires when one of tab is pushed inside the box (want to be able to pass
             * focus or do something else if tab is pushed instead of inserting \t)
             * @param {Rally.technicalservices.accessible.htmleditor} this
             * @param {Boolean} shift key also pressed
             */
            'tab'
        );
    },
    // get tabs out of the html editor
    fixKeys: (function() { // load time branching for fastest keydown performance
        if (Ext.isIE) {
            return function(e){
                var me = this,
                    k = e.getKey(),
                    doc = me.getDoc(),
                    readOnly = me.readOnly,
                    range, target;

                if (k === e.TAB) {
                    e.stopEvent();
//                    if (!readOnly) {
//                        range = doc.selection.createRange();
//                        if(range){
//                            range.collapse(true);
//                            range.pasteHTML('&#160;&#160;&#160;&#160;');
//                            me.deferFocus();
//                        }
//                    }
                }
                else if (k === e.ENTER) {
                    if (!readOnly) {
                        range = doc.selection.createRange();
                        if (range) {
                            target = range.parentElement();
                            if(!target || target.tagName.toLowerCase() !== 'li'){
                                e.stopEvent();
                                range.pasteHTML('<br />');
                                range.collapse(false);
                                range.select();
                            }
                        }
                    }
                }
            };
        }

        if (Ext.isOpera) {
            return function(e){
                var me = this;
                if (e.getKey() === e.TAB) {
                    e.stopEvent();
//                    if (!me.readOnly) {
//                        me.win.focus();
//                        me.execCmd('InsertHTML','&#160;&#160;&#160;&#160;');
//                        me.deferFocus();
//                    }
                }
            };
        }

        if (Ext.isWebKit) {
            return function(e){
                var me = this,
                    k = e.getKey(),
                    readOnly = me.readOnly;

                if (k === e.TAB) {
                    
                    e.stopEvent();
                    // the tab event return this editor and shift_key_pressed
                    me.fireEvent('tab',me,e.shiftKey);
//                    if (!readOnly) {
//                        me.execCmd('InsertText','\t');
//                        me.deferFocus();
//                    }
                }
                else if (k === e.ENTER) {
                    e.stopEvent();
                    if (!readOnly) {
                        me.execCmd('InsertHtml','<br /><br />');
                        me.deferFocus();
                    }
                }
            };
        }

        return null; // not needed, so null
    }()),
    //docs inherit from Field
    // add clearing bad characters
    getValue : function() {
        var me = this,
            value;
        if (!me.sourceEditMode) {
            me.syncValue();
        }
        value = me.rendered ? me.textareaEl.dom.value : me.value;
        value = me.cleanValue(value);
        me.value = value;
        return value;
    },
    cleanValue: function(value) {
        var clean_value = value.replace(/\&nbsp;/g," ");
        
        return clean_value;
    }
});

Ext.define('Rally.technicalservices.accessible.grid', {
    extend: 'Ext.container.Container',
    alias: 'widget.tsaccessiblegrid',
    config: {
         /**
         * @cfg {String} 
         * Embedded into the table definition as the caption
         * 
         * Defaults to the value of title
         */
        caption: null,
         /**
         * @cfg {String} title
         * Embedded into the table definition as the summary
         * 
         * Defaults to 'Grid Title'
         */
        title: 'Grid Title',
        /**
         * @cfg {String} editFieldName
         * When an edit button is displayed, value from this field on the record will
         * follow 'Edit'.  For example, set to 'FormattedID' for the button to say, 'Edit US72'
         * 
         */
        editFieldName: null,
        /**
         * @cfg {@Rally.data.WsapiDataStoreView} Must be a WsapiDataStore
         * 
         */
        store: null,
        /**
         * @cfg {Array}
         * Accepts {@link Ext.grid.Panel} column configs
         */
        columns: []
    },
    
    initComponent: function(){
        this.callParent();
        this.addEvents(
            /**
             * @event recordeditclick
             * Fires when the edit button for a record is clicked
             * @param {Rally.technicalservices.accessible.grid} this
             * @param {Ext.data.Model} Rally record for the selected row
             */
            'recordeditclick'
        );
    },
    
    renderTpl: [
        '<table border="1" cellspacing="1" cellpadding="1" summary="{summary}">',
        '<caption>{caption}</caption>',
        '<thead><tr>',
        '<tpl for="columns">',
        '<th scope="col">{text}</th>',
        '</tpl>',
        '<th scope="col">Edit</th>',
        '</tr></thead>',
        '<tbody>',
            '<tpl for="data">',
                '<tr>',
                    '<tpl for="parent.columns">',
                        '<tpl if="xindex === 1">',
                            '<th scope="row">',
                            '{[parent.data[values.dataIndex] ? parent.data[values.dataIndex] : "..." ]}',
                            '</th>',
                        '</tpl>',
                        '<tpl if="xindex &gt; 1">',
                            '<td>',
                            '{[parent.data[values.dataIndex] ? parent.data[values.dataIndex] : "" ]}',
                            '</td>',
                        '</tpl>',
                    '</tpl>',
                    '<td><button id="button-{#}" title="Edit{data.TitleText}">Edit{data.EditText}</button></td>',
                '</tr>',
            '</tpl>',
        '</tbody>',
        '</table>'
    ],
    
    renderTpl_past: [ '{html}'],
    
    getTemplateArgs: function() {
        var data = [];
        var me = this;
        if (this.store) {
            data = this.store.getRecords();
        }
        if ( data.length == 0 ) {
            this.renderTpl = "No records found";
        }
        Ext.Array.each(data, function(datum){
            datum.set('EditText',"");
            datum.set('TitleText',"");
            if (me.editFieldName && datum.get(me.editFieldName) ) {
                var text = datum.get(me.editFieldName);
                datum.set('TitleText'," " + text);
                if ( text.length > 10 ) {
                    text = text.substring(0,9) + ' ...';
                }
                datum.set('EditText',' ' + text);
            }
        });
        
        return {
            summary: this.title,
            caption: this.caption || this.title,
            columns: this.columns,
            data: data
        }
    },
    /*
     * return number of items in the grid
     */
    getCount: function() {
        var count = 0;
        if ( this.store ) {
            count = this.store.getCount();
        }
        return count;
    },
    beforeRender: function() {
        var me = this;
        me.callParent();
        
        Ext.applyIf(me.renderData, me.getTemplateArgs());
    },
    
    afterRender: function() {
        var me = this;
        if ( this.store ) {
            for (var i=0; i<this.store.getRecords().length; i++) {
                Ext.get('button-' + i).addListener('click', me._editButtonClickHandler, this);
            }
            var first_button = Ext.get('button-0');
            if ( first_button ) {
                first_button.focus();
            }
        }
    },
    
    _editButtonClickHandler: function(extEventObject, buttonEl, eOpts) {
        var buttonId = buttonEl.id;
        var rowIndex = parseInt( buttonId.replace(/^\D+/g, ''), 10 );
        var recordToEdit = this.store.getAt(rowIndex);
        this.fireEvent('recordeditclick', this, recordToEdit);
     
    }
   
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Accessible App'
               });
        });
    </script>
    
    
<link rel="stylesheet" type="text/css" href="src/style/app.css">

</head>
<body></body>
</html>